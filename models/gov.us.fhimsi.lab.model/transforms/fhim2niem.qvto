import FHIMLibrary;
import Strings;

modeltype uml uses 'http://www.eclipse.org/uml2/3.0.0/UML';
modeltype ecore "strict" uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype term uses 'http://www.openhealthtools.org/mdht/schemas/term/1';


transformation fhim2niem(in fhimModel : uml,in niemCoreModel : uml, out niemModel : uml );

main() {
	
	log('Transforming Federal Health Information Model (PIM) to National Information Exchange Model (PSM)');
	
	// Currently hard coded vocabulary import - need to add dynamic discovery support
//	var vocabularyPackage :=  fhimModel.rootObjects()[uml::Model]->getPackageImport('HITSP-C80')->asSequence()->first();

//	log('vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv');
//	var xsdPackage :=  niemCoreModel.rootObjects()[uml::Model]->getPackageImport('XSDDataTypes')->asSequence()->first(); 
//	log('vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv');
	
	// Create NIEM PSM
	fhimModel.rootObjects()[uml::Package]-> map toNIEM();
	
	

	
}



mapping uml::Package::toNIEM() : uml::Package
{
	// Clone the FHIM instance to NIEM instance
	init{
		result := self.deepclone().oclAsType(Package);
		
	}

		//niemCoreModel.rootObjects()[uml::Package].getImportedPackages()->select(name='HITSP-C80')->asSequence();
	

	// Update the generalizations of the extension 
	result.allSubobjects()[uml::Generalization].map mapGeneralizations(); 
	
	// Update and bind to terminology model 
	 result.allSubobjects()[uml::Class] -> map mapTerminology();
	 

	// update the name - do this last
	result.name := self.name;

	// Create the 3 niem packages for teh exchange
	var extensionPackage : uml::Package := object uml::Package  {
		name := 'Extension';
	}	;

	var constraintPackage : uml::Package := object uml::Package  {
		name := 'Constraints';
	}	;

   var exchangePackage : uml::Package := object uml::Package  {
		name := 'Exchange';
	};

	extensionPackage.ownedType += result.ownedType->select(ownedComment->getMappings('niem=')->asSequence()->first() = 'Extension');
	
	constraintPackage.ownedType += result.ownedType;
	
	

	var exchangeClass : uml::Class := object uml::Class
	{
		name := 'Exchange'
	};
	
	
	
	exchangePackage.ownedType += exchangeClass;
	
	var xsdGlobalStereotype : uml::Stereotype := exchangeClass.getApplicableStereotype('XMLSchema::GlobalProperty');

	exchangeClass.applyStereotype(xsdGlobalStereotype);
		
	exchangeClass.ownedAttribute += constraintPackage.ownedType[uml::Class]->map mapConstraintsToExchange();
	
	exchangeClass.ownedAttribute[uml::Property]->map mapApplyXSDGlobalElement();
	
	 //update to niem naming convention
	constraintPackage.ownedType[uml::Class]-> map mapNiemNaming();


	result.packagedElement += extensionPackage;
	
	result.packagedElement += constraintPackage;
	
	result.packagedElement += exchangePackage;	
	
		// update the name - do this last
	result.name := 'niem'+self.name;
}



// map generalizations to niem core
mapping  inout uml::Generalization::mapGeneralizations() 
{
	log('Maping FHIM generalizations');	

	var niemClassName : String = '';
	
	niemClassName :=  self.owner.ownedComment->getMappings('niem=')->asSequence()->first();
	
	log ('Extension '+niemClassName  );
	
	if (niemClassName='Extension') then
	{
	log('aaa');
		self.destroy();
	} else {
	log('bbb');
		self.general := getFHIMClass(niemClassName);	
	} endif;
	

}

mapping inout uml::Class::mapTerminology() {
	
	log ('Mapping FHIM terminology ');
	
	nestedClassifier += self.ownedAttribute -> map mapTerminology();
	
	// Appying xsd after the add so the profile is available
	nestedClassifier[uml::Class]->map applyXSD(); 
	
}


mapping inout uml::Class::mapNiemNaming() {
	
	log ('Mapping FHIM Naming ');
	
	name := name +'Type';
	
	
}

mapping  uml::Class::mapConstraintsToExchange() : uml::Property {

	init {
		result := object uml::Property {
			name := self.name;
			type := self;
		};	
	}
	
	
}

mapping inout uml::Property::mapApplyXSDGlobalElement()  {

	var xsdGlobalStereotype : uml::Stereotype := getApplicableStereotype('XMLSchema::GlobalElement');

	applyStereotype(xsdGlobalStereotype);
	
}

mapping in uml::Stereotype::logAppliedStereotypes()
{
	log(self.qualifiedName + ' is applied ');
}

mapping inout uml::Property::mapTerminology() : uml::Class when { self.type != null and  self.type.name = 'CD'  }
{	

	// create the class restul
	init {
		result := object uml::Class {
		name := '_'+self.name;
		
		//general := getNIEMDatatype('token');
		
//		base = 'asdf';
		};	
	
		// value property 
		var valueProperty : uml::Property := 
		object uml::Property
		{
			name := 'value';
			//type := getNiemDataType('string');
		};
	
		// value set id attribute
		var valueSetIdProperty : uml::Property := 
		object uml::Property
		{
			name := 'valueSetId';
		};
	
		// get the corresponding fhim property
		var fhimProperty : uml::Property := getFHIMProperty(self.qualifiedName);

		fhimProperty.getAppliedStereotypes()->map logAppliedStereotypes();

		var termstereotype : uml::Stereotype := fhimProperty.getAppliedStereotype('CDA::ValueSetConstraint');
	
	log('stereotype'+termstereotype.repr());
	
	
	
		var enumerationSource : uml::Enumeration := getTerminologyEnumeration(fhimProperty.getValue(termstereotype,"reference").repr());
	
		var enumerationTarget : uml::Enumeration  := enumerationSource.deepclone().oclAsType(uml::Enumeration );
		
		enumerationTarget.general += getXSDType('token'); 
	
		var termstereotype2 : uml::Stereotype := enumerationSource.getAppliedStereotype('Terminology::ValueSetVersion');

		valueSetIdProperty.defaultValue := object uml::LiteralString {
			value  := enumerationSource.getValue(termstereotype2,"identifier")->oclAsType(String)->asSequence()->first();
		};

		result.ownedAttribute += valueProperty;

		result.ownedAttribute += valueSetIdProperty ;
	
		result.nestedClassifier += enumerationTarget ;
		
		// set the value to the inlined enumeration
		valueProperty.type := enumerationTarget;
		
	}

	// set the type of the property
	self.type := result;

}


mapping  inout uml::Class::createInnerClasses() 
{
	nestedClassifier += self.ownedAttribute -> map createInnerClasses() ;

}


// apply xsd to valuesetid 
mapping  inout uml::Property::applyXSD() 
{
	
	if (name = 'valueSetId') then
	{
		var xsdstereotype : uml::Stereotype := getApplicableStereotype('XMLSchema::Attribute');

		applyStereotype(xsdstereotype);
		
	}endif;
	 
}


mapping  inout uml::Class::applyXSD() 
{
	self.ownedAttribute[uml::Property] ->map applyXSD();
}

mapping inout uml::Property::createInnerClasses() : uml::Class
{
	
	init {
		result := object uml::Class {
			name := '_' + self.name;
			general := getNiemClass('anyType');
		};	
	}

	
	var p : uml::Property := 
	object uml::Property
	{
		name := 'valueSetId';
	};

	result.ownedAttribute += p;

	self.type = result;


}

query getXSDType(in xsdTypeName : String): uml::DataType {
	
	log('ffffffffffffffffffffffffffffffff');
	
	niemCoreModel.rootObjects()[uml::Model].packageImport->map displayPackage();
	
	var xsdPackage :=  niemCoreModel.rootObjects()[uml::Model]->getPackageImport('XSDDataTypes')->asSequence()->first(); 
	log('ffffffffffffffffffffffffffff');
	
	//var xsdPackage : uml::Package :=  niemCoreModel.rootObjects()[uml::Model]->getPackageImport('XSDDataTypes')->asSequence()->first();
	var xsdType := xsdPackage.allSubobjects()[uml::DataType]->asSequence()->select(xsdTypeName=name)->first();
	
	log(xsdType.repr());
	return xsdType;
}
	
query getNiemClass(in niemClassName: String ) : uml::Class
{   
   return niemCoreModel.objectsOfType(uml::Class)->asSequence()->select(niemClassName=name)->first();
}

query getNiemDataType(in niemClassName: String ) : uml::DataType
{   
   return niemCoreModel.objectsOfType(uml::DataType)->asSequence()->select(niemClassName=name)->first();
}

query getFHIMProperty(in fhimPropertyName: String ) : uml::Property
{   
   return fhimModel.objectsOfType(uml::Property)->asSequence()->select(fhimPropertyName=qualifiedName)->first();
}



query getFHIMClass(in fhimClassName: String ) : uml::Class
{   
   return niemCoreModel.objectsOfType(uml::Class)->asSequence()->select(fhimClassName=name)->first();
}


query getTerminologyEnumeration(in termClassName: String ) : uml::Enumeration
{
log('search for enumeration ' + termClassName);
	var vocabularyPackage :=  fhimModel.rootObjects()[uml::Package].getImportedPackages()->select(name='HITSP-C80')->asSequence()->first();   
	 
 var enumeration := vocabularyPackage.allSubobjects()[uml::Enumeration]->asSequence()->select(termClassName=qualifiedName)->first();

 return enumeration;
  
}


 

