modeltype uml uses 'http://www.eclipse.org/uml2/2.1.0/UML';
modeltype ecore "strict" uses ecore('http://www.eclipse.org/emf/2002/Ecore');

transformation fhim2niem(in fhimModel : uml,in niemCoreModel : uml, out niemModel : uml );

main() {
	
	log('Map FHIM to NIEM');

	fhimModel.rootObjects()[uml::Model]-> map toNIEM();
	
	


}

mapping uml::Model::toNIEM() : uml::Model
{
	init{
		result := self.deepclone().oclAsType(Model);
	}
	result.name := 'NIEM'+self.name;

	//result.allSubobjects()[uml::Generalization].map updateGeneralization(); 
	
	 result.allSubobjects()[uml::Class] -> map createInnerClasses();
	 
	 result.allSubobjects()[uml::Property] -> map applyXSD();
	

//result.ownedType += collectionTemplates->at(collectionTemplatesPosition)-> map toUMLCollectionClass(result);

}



mapping  inout uml::Generalization::updateGeneralization() 
{
	log('Maping generalizations');	

	var c := niemCoreModel.objectsOfType(uml::Class)->asSequence();
	
	var ctr : Integer := 1;
	
	var neimClass : uml::Class := null;
	
	while(ctr <= c->size() )
	{
		if ( c->at(ctr).name = 'PersonType') then
		{
			neimClass := c->at(ctr);			
			self.general := neimClass;			
		} endif;
		
		ctr := ctr + 1;	
	};
	

	
	

}

mapping inout uml::Property::applyTerminology()
{	

	if (self.type != null) then {
		if (self.type.name = 'Code') then {			
			log('applying Terminology to ' + self.qualifiedName);		
			log('applying Terminology to ' + self.owner.repr());			
			//if ( self.owner.oclIsTypeOf(uml::Class )) then {
				var ownerClass : uml::Class := self.owner.oclAsType(uml::Class);
				ownerClass.nestedClassifier += object uml::Class
				{
					name = 'InnerClass' + self.name;
				}; 
			//} endif;			
		}endif;
	} endif;
}


mapping  inout uml::Class::createInnerClasses() 
{
	nestedClassifier += self.ownedAttribute -> map createInnerClasses() ;
	
//	self.nestedClassifier += object uml::Class
//	{
//		
//	};
	
	 
}

mapping  inout uml::Property::applyXSD() 
{
	
	if (name = 'valueSetId') then
	{
		var xsdstereotype : uml::Stereotype := getApplicableStereotype('XMLSchema::Attribute');
	log('asdfasdfasdf'+xsdstereotype.repr() );
	applyStereotype(xsdstereotype);
		
	}endif;
	
	//nestedClassifier += self.ownedAttribute -> map createInnerClasses() ;
	
//	self.nestedClassifier += object uml::Class
//	{
//		
//	};
	
	 
}

mapping inout uml::Property::createInnerClasses() : uml::Class
{
	
	
init {
	result := object uml::Class {
	name := '_' + self.name;
	};


	
}

	var c := niemCoreModel.objectsOfType(uml::Class)->asSequence();
	
	var ctr : Integer := 1;
	
	var neimClass : uml::Class := null;
	
	while(ctr <= c->size() )
	{
		//log(c->at(ctr).name );
		if ( c->at(ctr).name = 'anyType') then
		{
			neimClass := c->at(ctr);			
			result.general := neimClass;			
		} endif;
		
		ctr := ctr + 1;	
	};
	
	
	
	
	
	var p : uml::Property := 
	object uml::Property
	{
		name := 'valueSetId';
		
		
	};

	result.ownedAttribute += p;
	
//	var xsdstereotype : uml::Stereotype := p.getApplicableStereotype('XMLSchema::Attribute');
//	log('asdfasdfasdf'+xsdstereotype.repr() );
//	p.applyStereotype(xsdstereotype);
			//hdfstereotype := properties->at(propertyPosition).	

self.type = result;


}



 
 
 
 

